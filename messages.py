from __future__ import annotations

import struct
from collections.abc import MutableSequence
from typing import Iterable, overload

from PyQt6.QtCore import Qt

from hid import QT_TO_HID, QT_TO_HID_MODIFIERS

# Documentation comments generated by AI.


class DOOMKeystroke:
    """
    Represents a single input state for the DOOM engine using USB HID format.

    Each keystroke may be serialized into a 4-byte packet: 1 byte for modifier flags
    and 3 bytes for concurrent HID key codes.

    Attributes:
        modifiers (int): A bitmask representing active modifiers (Shift, Ctrl, Alt).
        keys (tuple[int, int, int]): A triplet of HID usage IDs. Unused slots
            must be padded with 0x00.

    Example:
        >>> keystroke = DOOMKeystroke(modifiers=0x02, keys=(0x04, 0x05, 0x00))
        >>> bytes(keystroke)
        b'\\x02\\x04\\x05\\x00'
    """

    def __init__(self, modifiers: int, keys: tuple[int, int, int]):
        self.modifiers = modifiers
        self.keys = keys

    def __repr__(self):
        return f"DOOMKeystroke(modifiers={self.modifiers:#x}, keys=({self.keys[0]:#x}, {self.keys[1]:#x}, {self.keys[2]:#x}))"

    def __bytes__(self):
        """
        Serializes the keystroke into 4 bytes.

        Format: [Modifier Byte][Key 1][Key 2][Key 3] (Big-Endian).
        """
        return struct.pack("!BBBB", self.modifiers, *self.keys)

    def is_idle(self) -> bool:
        """
        Determines if the keystroke represents an 'idle' state (no keys pressed).

        Returns:
            bool: True if all modifiers and key slots are zero.
        """
        return (
            self.modifiers == 0
            and self.keys[0] == 0
            and self.keys[1] == 0
            and self.keys[2] == 0
        )

    @classmethod
    def from_qt_keys(cls, keys: Iterable[Qt.Key]) -> DOOMKeystroke:
        """
        Factory method to create a DOOMKeystroke from PyQt6 key constants.

        Maps Qt.Key values to their corresponding USB HID equivalents using
        internal translation tables. Supports up to 3 non-modifier keys;
        additional keys are *ignored*.

        Args:
            keys: An iterable of Qt.Key values to convert.

        Returns:
            DOOMKeystroke: An initialized instance ready for serialization.

        Example:
            >>> keystroke = DOOMKeystroke.from_qt_keys([Qt.Key.Key_A, Qt.Key.Key_Shift])
            >>> repr(keystroke)
            DOOMKeystroke(modifiers=0x02, keys=(0x04, 0x00, 0x00))
        """

        modifiers = 0
        key_entries = []

        for key in keys:
            if modifier := QT_TO_HID_MODIFIERS.get(key):
                modifiers |= modifier
            elif hid_key := QT_TO_HID.get(key):
                key_entries.append(hid_key)

        # Pad with zeros and slice to ensure exactly 3 key slots
        key_tuple = tuple((key_entries + [0, 0, 0])[:3])

        return cls(modifiers, key_tuple)


class DOOMKeystrokeList(MutableSequence[DOOMKeystroke]):
    """Container for managing a sequence of DOOM keystrokes.

    This class provides a list-like interface for storing and manipulating
    DOOMKeystroke objects. It handles serialization to binary format,
    includes utilities for cleaning up trailing null keystrokes, and tracks
    the total size in bytes.

    Attributes:
        keystrokes (list[DOOMKeystroke]): The internal list of keystroke objects.

    Example:
        >>> ks_list = DOOMKeystrokeList()
        >>> ks_list.append(DOOMKeystroke(0x00, (0x04, 0x00, 0x00)))
        >>> len(ks_list)
        1
        >>> ks_list.size_in_bytes
        4
    """

    def __init__(self, keystrokes: Iterable[DOOMKeystroke] | None = None):
        self._keystrokes: list[DOOMKeystroke] = list(keystrokes) if keystrokes else []

    @overload
    def __getitem__(self, index: int) -> DOOMKeystroke: ...
    @overload
    def __getitem__(self, index: slice) -> MutableSequence[DOOMKeystroke]: ...
    def __getitem__(self, index):
        return self._keystrokes.__getitem__(index)

    @overload
    def __setitem__(self, index: int, value: DOOMKeystroke) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: Iterable[DOOMKeystroke]) -> None: ...
    def __setitem__(self, index, value):
        return self._keystrokes.__setitem__(index, value)

    def __delitem__(self, index: int | slice) -> None:
        self._keystrokes.__delitem__(index)

    def __len__(self) -> int:
        return len(self._keystrokes)

    def insert(self, index: int, value: DOOMKeystroke) -> None:
        self._keystrokes.insert(index, value)

    @property
    def size_in_bytes(self) -> int:
        """
        Returns the byte length of the keystroke data payload (4 bytes per entry).
        Does not include the 1-byte length header used in __bytes__.
        """
        return len(self._keystrokes) * 4

    def remove_trailing_idles(self):
        """
        Truncates all idle (empty) keystrokes from the end of the sequence
        to save bandwidth/space.
        """
        while self._keystrokes and self._keystrokes[-1].is_idle():
            self._keystrokes.pop()

    def __repr__(self):
        items = "\n".join(f"    {k!r}," for k in self._keystrokes)
        return f"DOOMKeystrokeList([\n{items}\n])"

    def split_to_serialise(self) -> list[DOOMKeystrokeList]:
        """
        Splits the list into chunks of 255 keystrokes.

        Because the serialization format uses a single byte to indicate count,
        individual packets cannot exceed 255 keystrokes.

        Returns:
            list[DOOMKeystrokeList]: A list of objects, each within serializable limits.
        """
        if len(self) <= 255:
            return [self]

        return [DOOMKeystrokeList(self[i : i + 255]) for i in range(0, len(self), 255)]

    def __bytes__(self):
        """
        Serializes the list into a binary packet.

        Format:
            - Byte 0: Number of keystrokes (N) as an unsigned 8-bit integer.
            - Bytes 1 to (N*4): Keystroke data.

        Raises:
            ValueError: If the list contains more than 255 keystrokes.
        """

        if len(self) > 255:
            raise ValueError(
                "DOOMKeystrokeList exceeds maximum serializable length (255)."
            )

        entries = b"".join(bytes(k) for k in self._keystrokes)
        return struct.pack("!B", len(self)) + entries
